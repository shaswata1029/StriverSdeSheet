class DSU{
  vector<int>parent;
    vector<int>size;
    
    public:
    DSU(int n){
        for(int index=0;index<n;index++){
            parent.push_back(index);
            size.push_back(1);
        }
    }
    
    int find(int node){
        if(node==parent[node])
            return node;
        return parent[node]=find(parent[node]);
    }
    
    bool merge(int x,int y){
        int px=find(x);
        int py=find(y);
        
        if(px==py)
            return false;
        
        if(size[py]>size[px])
            swap(px,py);
        
        parent[py]=px;
        size[px]+=size[py];
        
        return true;
    }
    
    int findSize(int node){
        return size[find(node)];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n=graph.size();
        DSU d(n);
        set<int>s(initial.begin(),initial.end());
        
        for(int node=0;node<n;node++){
            for(int nbr=0;nbr<n;nbr++){
                if(node!=nbr && graph[node][nbr]==1 && s.find(node)==s.end() && s.find(nbr)==s.end())
                    d.merge(node,nbr);
            }
        }
        
        map<int,set<int>>nodes;
        unordered_map<int,int>freq;
        
        for(auto node:s){
            set<int>parents;
            
            for(int nbr=0;nbr<n;nbr++){
                if(node!=nbr && graph[node][nbr]==1 && s.find(nbr)==s.end()){
                    int parent=d.find(nbr);
                    parents.insert(parent);
                }
            }
            
            for(auto parent:parents)
                freq[parent]++;
            nodes[node]=parents;
        }
        
        int maxAns=INT_MIN;
        int ansNode=-1;
        
        for(auto node:s){
            int curAns=0;
            
            for(auto &parent:nodes[node]){
                if(freq[parent]==1)
                    curAns+=d.findSize(parent);
            }
            
            if(curAns>maxAns){
                maxAns=curAns;
                ansNode=node;
            }else if(curAns==maxAns)
                ansNode=min(ansNode,node);
        }
        
        return ansNode;
        
    }
};