class DSU{
    vector<int>parent;
    vector<int>size;
    
    public:
    DSU(int n){
        for(int index=0;index<n;index++){
            parent.push_back(index);
            size.push_back(1);
        }
    }
    
    int find(int node){
        if(node==parent[node])
            return node;
        return parent[node]=find(parent[node]);
    }
    
    bool merge(int x,int y){
        int px=find(x);
        int py=find(y);
        
        if(px==py)
            return true;
        
        if(size[py]>size[px])
            swap(px,py);
        
        parent[py]=px;
        size[px]+=size[py];
        
        return false;
    }
    
    int findSize(int node){
        return size[find(node)];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n=graph.size();
        DSU d(n);
        
        for(int node=0;node<n;node++){
            for(int nbr=0;nbr<n;nbr++){
                if(node!=nbr && graph[node][nbr]==1)
                 d.merge(node,nbr);   
            }
        }
        
        unordered_map<int,int>parent;
        
        int size=initial.size();
        for(int index=0;index<size;index++){
            int node=initial[index];
            
            int curParent=d.find(node);
            parent[curParent]++;
        }
        
        int maxNodes=0;
        int node=INT_MAX;
        
        for(int index=0;index<size;index++){
            int curNode=initial[index];
            int curParent=d.find(curNode);
            
            int curNodes=0;
            if(parent[curParent]==1)
                curNodes=d.findSize(curParent);
            
            if(curNodes>maxNodes){
                maxNodes=curNodes;
                node=curNode;
            }else if(curNodes==maxNodes)
                node=min(node,curNode);
        }
        
        return node;
        
    }
};